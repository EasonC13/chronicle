defmodule Broker.Collector.BundleCollector.Recollector do

  require Logger
  alias Core.Utils.Converter
  @backup_nodes Application.get_env(:broker, :__BACKUP_NODES__)
  @retries Application.get_env(:broker, :__RETERIES_RECOLLECTOR__) || 5
  @max_time_recollector Application.get_env(:broker, :__MAX_TIME_RECOLLECTOR__) || "5.5"
  @empty_trytes "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"

  use GenServer

  def start_link(state) do
    GenServer.start(__MODULE__, state)
  end

  def init(state) do
    %{snapshot_index: snapshot_index} = state[:bundle]
    send(self(), {:recollect, snapshot_index})
    {:ok, state}
  end

  def handle_info({:recollect, snapshot_index}, %{bundle: bundle} = state) do
    [%{current_index: cx, last_index: lx,trunk: trunk} | _] = bundle
    cond do
      cx == lx ->
        # this indicate it's the last required tx_object, and the bundle is ready
        # to be send back to BundleCollector
        send(state[:response_to], {:recollected_bundle, bundle})
        {:stop, :normal, state}
      true ->
        # the bundle not yet complete, therefore we should collect the next transaction
        # using trunk and getTrytes api call, we can query either other permanode or IRI.
        _stop_or_noreply = recollect(snapshot_index,trunk,state,@retries)
    end
  end

  # unfortunately consumed all retries. wasn't able to collect the bundle :(
  defp recollect(_sx,_tk, state, 0) do
    %{hash: head_hash, bundle: bundle_hash} = List.last(state[:bundle])
    Logger.warn("Wasn't able to recollect the bundle_hash: #{bundle_hash}, head_hash: #{head_hash}")
    {:stop, :normal, state}
  end

  defp recollect(snapshot_index, trunk, %{bundle: bundle} = state, retries) do
    # we select random backup_node url from @backup_nodes to achieve better load balance.
    args =  ["--max-time", @max_time_recollector,Enum.random(@backup_nodes), "-X","POST",
    "-H", "Content-Type: application/json",
    "-H", "X-IOTA-API-Version: 1",
    "-d", """
    { "command": "getTrytes", "hashes": [ "#{trunk}" ]}
    """]
    {result, _} = System.cmd("curl", args, [])
    case result do
      <<_::11-bytes, trytes::2673-bytes, _::binary>> when trytes != @empty_trytes ->
        # process trytes into a tx_object and store it in bundle
        tx_object = Converter.trytes_to_tx_object(trunk, trytes, snapshot_index)
        # send recollect again
        send(self(), {:recollect, snapshot_index})
        # return updated state with up to recent tx-object in bundle
        state = %{state | bundle: [tx_object|bundle]}
        {:noreply, state}
      _ ->
       # retry for the same trunk as long retries != 0
       recollect(snapshot_index,trunk, state, retries-1)
    end
  end

end
